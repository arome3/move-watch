import type { RiskPatternDefinition } from '../types.js';

/**
 * Exploit detection patterns
 * Detects: Reentrancy, Flash Loans, Oracle Manipulation, Integer Overflow
 */
export const EXPLOIT_PATTERNS: RiskPatternDefinition[] = [
  // 1. Reentrancy Detection - External call patterns
  {
    id: 'exploit:reentrancy:external_call',
    category: 'EXPLOIT',
    severity: 'CRITICAL',
    name: 'Potential Reentrancy',
    description: 'External call detected that could allow reentrancy attacks',
    matchCriteria: {
      functionPatterns: [
        /::callback/i,
        /::external_call/i,
        /::invoke_external/i,
        /::call_contract/i,
      ],
      customMatcher: (data) => {
        // Check for callback patterns in function name
        const fnLower = data.functionBaseName.toLowerCase();
        if (
          fnLower.includes('callback') ||
          fnLower.includes('external') ||
          fnLower.includes('hook')
        ) {
          // Check if there are balance-related events after external calls
          const events = data.simulationResult?.events || [];
          const hasTransfer = events.some((e) => /transfer|withdraw|deposit/i.test(e.type));
          if (hasTransfer) {
            return {
              matched: true,
              patternId: 'exploit:reentrancy:external_call',
              category: 'EXPLOIT',
              severity: 'CRITICAL',
              confidence: 0.75,
              evidence: {
                functionName: data.functionName,
                hasTransferEvents: true,
              },
            };
          }
        }
        return null;
      },
    },
    issueTemplate: {
      title: 'Reentrancy Vulnerability Detected',
      description:
        'This transaction makes an external call that could potentially allow reentrancy attacks. State changes may occur in an unexpected order.',
      recommendation:
        'Ensure state is updated before making external calls (checks-effects-interactions pattern). Consider using reentrancy guards.',
    },
  },

  // 2. Flash Loan Detection
  {
    id: 'exploit:flashloan:borrow_repay',
    category: 'EXPLOIT',
    severity: 'HIGH',
    name: 'Flash Loan Pattern',
    description: 'Flash loan borrow and repay detected in same transaction',
    matchCriteria: {
      functionPatterns: [/::flash_loan/i, /::flashloan/i, /::flash_borrow/i],
      eventPatterns: [
        { type: /FlashLoan|Borrow.*Repay/i, required: false },
      ],
      customMatcher: (data) => {
        const events = data.simulationResult?.events || [];
        const fnLower = data.functionBaseName.toLowerCase();

        // Check for flash loan function patterns
        if (
          fnLower.includes('flash') ||
          fnLower.includes('flashloan') ||
          fnLower.includes('flash_borrow')
        ) {
          return {
            matched: true,
            patternId: 'exploit:flashloan:borrow_repay',
            category: 'EXPLOIT',
            severity: 'HIGH',
            confidence: 0.9,
            evidence: {
              functionName: data.functionName,
              eventCount: events.length,
            },
          };
        }

        // Check for borrow+repay event pattern
        const hasBorrow = events.some((e) => /borrow|loan/i.test(e.type));
        const hasRepay = events.some((e) => /repay|return/i.test(e.type));
        if (hasBorrow && hasRepay) {
          return {
            matched: true,
            patternId: 'exploit:flashloan:borrow_repay',
            category: 'EXPLOIT',
            severity: 'HIGH',
            confidence: 0.85,
            evidence: {
              hasBorrowEvent: true,
              hasRepayEvent: true,
            },
          };
        }

        return null;
      },
    },
    issueTemplate: {
      title: 'Flash Loan Transaction Detected',
      description:
        'This transaction uses flash loans, which borrow and repay in the same transaction. Flash loans can be used for price manipulation or exploits.',
      recommendation:
        'Review the flash loan usage carefully. Ensure oracle prices are not manipulated and that the protocol has proper safeguards.',
    },
  },

  // 3. Oracle Manipulation Detection
  {
    id: 'exploit:oracle:price_manipulation',
    category: 'EXPLOIT',
    severity: 'CRITICAL',
    name: 'Oracle Manipulation Risk',
    description: 'Price update detected before trade execution',
    matchCriteria: {
      functionPatterns: [
        /::update_price/i,
        /::set_price/i,
        /::oracle/i,
        /::price_feed/i,
      ],
      customMatcher: (data) => {
        const events = data.simulationResult?.events || [];
        const fnLower = data.functionName.toLowerCase();

        // Helper to find first matching event index
        const findEventIndex = (pattern: RegExp): number => {
          const idx = events.findIndex((e) => pattern.test(e.type));
          return idx;
        };

        // Direct oracle manipulation functions combined with swap
        if (
          fnLower.includes('set_price') ||
          fnLower.includes('update_price') ||
          fnLower.includes('oracle')
        ) {
          const hasSwap = events.some((e) => /swap|trade|exchange/i.test(e.type));
          if (hasSwap) {
            return {
              matched: true,
              patternId: 'exploit:oracle:price_manipulation',
              category: 'EXPLOIT',
              severity: 'CRITICAL',
              confidence: 0.9,
              evidence: {
                functionName: data.functionName,
                hasSwapAfterPriceUpdate: true,
                reason: 'Oracle function name detected with swap events',
              },
            };
          }
        }

        // Check event ORDER - price update BEFORE swap is suspicious
        // Swap BEFORE price update is normal (oracle updating based on trade)
        const priceEventIndex = findEventIndex(/price|oracle|feed/i);
        const swapEventIndex = findEventIndex(/swap|trade|exchange/i);

        // Only suspicious if BOTH events exist
        if (priceEventIndex === -1 || swapEventIndex === -1) {
          return null;
        }

        // Check the order: price update BEFORE swap is the suspicious pattern
        const priceBeforeSwap = priceEventIndex < swapEventIndex;

        if (priceBeforeSwap) {
          // Suspicious: price updated before swap (manipulation pattern)
          return {
            matched: true,
            patternId: 'exploit:oracle:price_manipulation',
            category: 'EXPLOIT',
            severity: 'CRITICAL',
            confidence: 0.85,
            evidence: {
              priceEventIndex,
              swapEventIndex,
              priceEventType: events[priceEventIndex]?.type,
              swapEventType: events[swapEventIndex]?.type,
              reason: 'Price updated BEFORE swap - manipulation pattern detected',
            },
          };
        } else {
          // Normal: swap happened before price update (oracle just reflecting the trade)
          // Still worth noting but much lower severity
          return {
            matched: true,
            patternId: 'exploit:oracle:price_manipulation',
            category: 'EXPLOIT',
            severity: 'LOW',
            confidence: 0.5,
            evidence: {
              priceEventIndex,
              swapEventIndex,
              priceEventType: events[priceEventIndex]?.type,
              swapEventType: events[swapEventIndex]?.type,
              reason: 'Swap BEFORE price update - likely normal oracle update',
            },
          };
        }
      },
    },
    issueTemplate: {
      title: 'Potential Oracle Manipulation',
      description:
        'A price oracle is updated in the same transaction as a trade. This pattern is commonly used in price manipulation attacks when the price is set BEFORE the trade.',
      recommendation:
        'Use time-weighted average prices (TWAP), Chainlink oracles, or other manipulation-resistant price feeds. Never trust prices that can be updated in the same transaction.',
    },
  },

  // 4. Integer Overflow Detection
  {
    id: 'exploit:overflow:large_values',
    category: 'EXPLOIT',
    severity: 'HIGH',
    name: 'Large Value Warning',
    description: 'Extremely large numeric values detected that may cause overflow',
    matchCriteria: {
      argumentPatterns: [
        {
          index: 'any',
          pattern: (value) => {
            if (typeof value === 'string' || typeof value === 'number') {
              try {
                const num = BigInt(value);
                // Check if > u64 max (Move commonly uses u64)
                return num > BigInt('18446744073709551615');
              } catch {
                return false;
              }
            }
            return false;
          },
        },
      ],
      customMatcher: (data) => {
        // Check all arguments for very large values
        const checkValue = (val: unknown): boolean => {
          if (typeof val === 'string' || typeof val === 'number') {
            try {
              const num = BigInt(val);
              return num > BigInt('18446744073709551615');
            } catch {
              return false;
            }
          }
          return false;
        };

        const largeValues: unknown[] = [];
        for (const arg of data.arguments) {
          if (checkValue(arg)) {
            largeValues.push(arg);
          }
          // Check nested arrays
          if (Array.isArray(arg)) {
            for (const item of arg) {
              if (checkValue(item)) {
                largeValues.push(item);
              }
            }
          }
        }

        if (largeValues.length > 0) {
          return {
            matched: true,
            patternId: 'exploit:overflow:large_values',
            category: 'EXPLOIT',
            severity: 'HIGH',
            confidence: 0.7,
            evidence: {
              largeValues: largeValues.map(String),
              count: largeValues.length,
            },
          };
        }

        return null;
      },
    },
    issueTemplate: {
      title: 'Potential Integer Overflow',
      description:
        'Transaction arguments contain extremely large values that exceed typical u64 range. This could cause arithmetic overflow.',
      recommendation:
        'Verify that arithmetic operations handle large numbers correctly. Check for overflow protection in the contract.',
    },
  },

  // 5. Sandwich Attack Vulnerability
  {
    id: 'exploit:mev:sandwich_vulnerable',
    category: 'EXPLOIT',
    severity: 'MEDIUM',
    name: 'Sandwich Attack Vulnerable',
    description: 'Swap transaction that may be vulnerable to sandwich attacks',
    matchCriteria: {
      functionPatterns: [
        /::swap/i,
        /::exchange/i,
        /::trade/i,
        /::add_liquidity/i,
      ],
      customMatcher: (data) => {
        const fnLower = data.functionBaseName.toLowerCase();

        // Check if it's a swap-like function
        if (
          fnLower.includes('swap') ||
          fnLower.includes('exchange') ||
          fnLower.includes('trade')
        ) {
          // Check for slippage parameters (min_amount_out)
          const hasSlippageProtection = data.arguments.some((arg) => {
            if (typeof arg === 'string' || typeof arg === 'number') {
              const num = Number(arg);
              // If there's a small non-zero minimum, that's slippage protection
              return num > 0 && num < 1e18;
            }
            return false;
          });

          return {
            matched: true,
            patternId: 'exploit:mev:sandwich_vulnerable',
            category: 'EXPLOIT',
            severity: hasSlippageProtection ? 'LOW' : 'MEDIUM',
            confidence: 0.6,
            evidence: {
              functionName: data.functionName,
              hasSlippageProtection,
            },
          };
        }

        return null;
      },
    },
    issueTemplate: {
      title: 'Sandwich Attack Vulnerability',
      description:
        'This swap transaction may be vulnerable to MEV sandwich attacks. Attackers can front-run and back-run your trade to extract value.',
      recommendation:
        'Set tight slippage limits, use private transaction pools, or use MEV-protected RPC endpoints.',
    },
  },
];

export default EXPLOIT_PATTERNS;
