generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// User tiers for rate limiting and features
enum Tier {
  FREE
  PRO
  TEAM
  ENTERPRISE
}

// Supported networks
enum Network {
  MAINNET
  TESTNET
  DEVNET
}

// Alert condition types
enum AlertConditionType {
  TX_FAILED
  BALANCE_THRESHOLD
  EVENT_EMITTED
  GAS_SPIKE
}

// Notification channel types
enum ChannelType {
  DISCORD
  SLACK
  TELEGRAM
  WEBHOOK
}

// Threshold comparison operators
enum ThresholdOperator {
  GT   // Greater than
  LT   // Less than
  EQ   // Equal to
  GTE  // Greater than or equal
  LTE  // Less than or equal
}

// User model with NextAuth.js support
model User {
  id            String       @id @default(cuid())
  email         String?      @unique
  walletAddress String?      @unique @map("wallet_address")
  name          String?
  image         String?
  tier          Tier         @default(FREE)

  // NextAuth.js fields
  emailVerified DateTime?    @map("email_verified")
  accounts      Account[]
  sessions      Session[]

  // Application relations
  simulations      Simulation[]
  alerts           Alert[]
  watchedContracts WatchedContract[]

  createdAt     DateTime     @default(now()) @map("created_at")
  updatedAt     DateTime     @updatedAt @map("updated_at")

  @@map("users")
}

// Simulation model for storing transaction simulation results
model Simulation {
  id            String    @id @default(cuid())
  shareId       String    @unique @default(cuid()) @map("share_id")

  // Owner (nullable for anonymous simulations)
  userId        String?   @map("user_id")
  user          User?     @relation(fields: [userId], references: [id], onDelete: SetNull)

  // Request parameters
  network       Network
  sender        String?
  functionName  String    @map("function_name")  // Full path: 0x1::coin::transfer
  typeArguments String[]  @map("type_arguments")
  arguments     Json      @default("[]")
  maxGasAmount  Int       @default(100000) @map("max_gas_amount")
  gasUnitPrice  Int       @default(100) @map("gas_unit_price")

  // Response data
  success       Boolean
  gasUsed       Int?      @map("gas_used")
  gasBreakdown  Json?     @map("gas_breakdown")  // { computation: number, storage: number }
  stateChanges  Json?     @map("state_changes")  // StateChange[]
  events        Json?                            // Event[]
  error         Json?                            // SimulationError | null
  rawResponse   Json?     @map("raw_response")   // Full VM response for debugging

  // Metadata
  createdAt     DateTime  @default(now()) @map("created_at")
  expiresAt     DateTime  @map("expires_at")

  @@index([userId])
  @@index([shareId])
  @@index([createdAt])
  @@index([expiresAt])
  @@map("simulations")
}

// Alert model for monitoring on-chain conditions
model Alert {
  id              String             @id @default(cuid())
  userId          String             @map("user_id")
  user            User               @relation(fields: [userId], references: [id], onDelete: Cascade)

  name            String
  enabled         Boolean            @default(true)
  network         Network            @default(TESTNET)

  // Condition configuration
  conditionType   AlertConditionType @map("condition_type")
  conditionConfig Json               @map("condition_config")  // Type-specific config

  // Notification settings
  channels        NotificationChannel[]
  cooldownSeconds Int                @default(60) @map("cooldown_seconds")

  // Statistics
  lastTriggeredAt DateTime?          @map("last_triggered_at")
  triggerCount    Int                @default(0) @map("trigger_count")

  // History
  triggers        AlertTrigger[]

  createdAt       DateTime           @default(now()) @map("created_at")
  updatedAt       DateTime           @updatedAt @map("updated_at")

  @@index([userId])
  @@index([conditionType])
  @@index([enabled])
  @@map("alerts")
}

// Notification channel configuration for alerts
model NotificationChannel {
  id          String      @id @default(cuid())
  alertId     String      @map("alert_id")
  alert       Alert       @relation(fields: [alertId], references: [id], onDelete: Cascade)

  type        ChannelType
  config      Json        // Channel-specific configuration (webhookUrl, botToken, etc.)
  enabled     Boolean     @default(true)

  createdAt   DateTime    @default(now()) @map("created_at")
  updatedAt   DateTime    @updatedAt @map("updated_at")

  @@index([alertId])
  @@map("notification_channels")
}

// Alert trigger history for tracking when alerts fired
model AlertTrigger {
  id                  String   @id @default(cuid())
  alertId             String   @map("alert_id")
  alert               Alert    @relation(fields: [alertId], references: [id], onDelete: Cascade)

  // Event that triggered the alert
  eventData           Json     @map("event_data")
  transactionHash     String?  @map("transaction_hash")

  // Notification results
  notificationsSent   String[] @map("notifications_sent")  // Channel types that succeeded
  notificationErrors  Json?    @map("notification_errors") // Errors by channel

  triggeredAt         DateTime @default(now()) @map("triggered_at")

  @@index([alertId])
  @@index([triggeredAt])
  @@map("alert_triggers")
}

// ============================================================================
// MONITORING DASHBOARD MODELS
// ============================================================================

// WatchedContract - contracts user wants to monitor on dashboard
model WatchedContract {
  id            String   @id @default(cuid())
  userId        String   @map("user_id")
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  moduleAddress String   @map("module_address")
  name          String?
  network       Network

  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")

  @@unique([userId, moduleAddress, network])
  @@index([userId])
  @@map("watched_contracts")
}

// ============================================================================
// NEXTAUTH.JS MODELS
// ============================================================================

// Account - OAuth provider connections (for NextAuth.js)
model Account {
  id                String  @id @default(cuid())
  userId            String  @map("user_id")
  type              String
  provider          String
  providerAccountId String  @map("provider_account_id")
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

// Session - user sessions (for NextAuth.js)
model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique @map("session_token")
  userId       String   @map("user_id")
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

// VerificationToken - email verification tokens (for NextAuth.js)
model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}
